{"version":3,"file":"vendors-b86c436e.76061f89a012ee79e2dc.js","mappings":"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","sources":["webpack://react-hello-webapp/./node_modules/react-router-dom/dist/index.js","webpack://react-hello-webapp/./node_modules/react-router/dist/index.js"],"sourcesContent":["/**\n * React Router DOM v6.4.4\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_enhanceManualRouteObjects, Router, useHref, useResolvedPath, useLocation, UNSAFE_DataRouterStateContext, UNSAFE_NavigationContext, useNavigate, createPath, UNSAFE_RouteContext, useMatches, useNavigation, UNSAFE_DataRouterContext } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, RouterProvider, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_DataStaticRouterContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, renderMatches, resolvePath, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { createRouter, createBrowserHistory, createHashHistory, ErrorResponse, invariant, joinPaths } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && ( // Ignore everything but left clicks\n  !target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\n\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n\n  for (let key of defaultSearchParams.keys()) {\n    if (!searchParams.has(key)) {\n      defaultSearchParams.getAll(key).forEach(value => {\n        searchParams.append(key, value);\n      });\n    }\n  }\n\n  return searchParams;\n}\nfunction getFormSubmissionInfo(target, defaultAction, options) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n\n  if (isFormElement(target)) {\n    let submissionTrigger = options.submissionTrigger;\n    method = options.method || target.getAttribute(\"method\") || defaultMethod;\n    action = options.action || target.getAttribute(\"action\") || defaultAction;\n    encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n    formData = new FormData(target);\n\n    if (submissionTrigger && submissionTrigger.name) {\n      formData.append(submissionTrigger.name, submissionTrigger.value);\n    }\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    } // <button>/<input type=\"submit\"> may override attributes of <form>\n\n\n    method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    action = options.action || target.getAttribute(\"formaction\") || form.getAttribute(\"action\") || defaultAction;\n    encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\n    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name\n    // matches an existing input name\n\n    if (target.name) {\n      formData.append(target.name, target.value);\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = options.method || defaultMethod;\n    action = options.action || defaultAction;\n    encType = options.encType || defaultEncType;\n\n    if (target instanceof FormData) {\n      formData = target;\n    } else {\n      formData = new FormData();\n\n      if (target instanceof URLSearchParams) {\n        for (let [name, value] of target) {\n          formData.append(name, value);\n        }\n      } else if (target != null) {\n        for (let name of Object.keys(target)) {\n          formData.append(name, target[name]);\n        }\n      }\n    }\n  }\n\n  let {\n    protocol,\n    host\n  } = window.location;\n  let url = new URL(action, protocol + \"//\" + host);\n  return {\n    url,\n    method,\n    encType,\n    formData\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\"],\n      _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"children\"],\n      _excluded3 = [\"reloadDocument\", \"replace\", \"method\", \"action\", \"onSubmit\", \"fetcherKey\", \"routeId\", \"relative\"];\n//#region Routers\n////////////////////////////////////////////////////////////////////////////////\n\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes: UNSAFE_enhanceManualRouteObjects(routes)\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes: UNSAFE_enhanceManualRouteObjects(routes)\n  }).initialize();\n}\n\nfunction parseHydrationData() {\n  var _window;\n\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n\n  return state;\n}\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);\n    } else {\n      serialized[key] = val;\n    }\n  }\n\n  return serialized;\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\n\n\nfunction BrowserRouter(_ref) {\n  let {\n    basename,\n    children,\n    window\n  } = _ref;\n  let historyRef = React.useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\n\nfunction HashRouter(_ref2) {\n  let {\n    basename,\n    children,\n    window\n  } = _ref2;\n  let historyRef = React.useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\n\nfunction HistoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    history\n  } = _ref3;\n  const [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n/**\n * The public API for rendering a history-aware <a>.\n */\n\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref4, ref) {\n  let {\n    onClick,\n    relative,\n    reloadDocument,\n    replace,\n    state,\n    target,\n    to,\n    preventScrollReset\n  } = _ref4,\n      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative\n  });\n\n  function handleClick(event) {\n    if (onClick) onClick(event);\n\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: href,\n      onClick: reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\n\n\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref5, ref) {\n  let {\n    \"aria-current\": ariaCurrentProp = \"page\",\n    caseSensitive = false,\n    className: classNameProp = \"\",\n    end = false,\n    style: styleProp,\n    to,\n    children\n  } = _ref5,\n      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator\n  } = React.useContext(UNSAFE_NavigationContext);\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp({\n      isActive,\n      isPending\n    });\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null].filter(Boolean).join(\" \");\n  }\n\n  let style = typeof styleProp === \"function\" ? styleProp({\n    isActive,\n    isPending\n  }) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to\n  }), typeof children === \"function\" ? children({\n    isActive,\n    isPending\n  }) : children);\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\n\n\nconst Form = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n    ref: ref\n  }));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\n\nconst FormImpl = /*#__PURE__*/React.forwardRef((_ref6, forwardedRef) => {\n  let {\n    reloadDocument,\n    replace,\n    method = defaultMethod,\n    action,\n    onSubmit,\n    fetcherKey,\n    routeId,\n    relative\n  } = _ref6,\n      props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n\n  let submit = useSubmitImpl(fetcherKey, routeId);\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let formAction = useFormAction(action, {\n    relative\n  });\n\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    submit(submitter || event.currentTarget, {\n      method,\n      replace,\n      relative\n    });\n  };\n\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  FormImpl.displayName = \"FormImpl\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\n\n\nfunction ScrollRestoration(_ref7) {\n  let {\n    getKey,\n    storageKey\n  } = _ref7;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\n\n\nvar DataRouterHook;\n\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmitImpl\"] = \"useSubmitImpl\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})(DataRouterHook || (DataRouterHook = {}));\n\nvar DataRouterStateHook;\n\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.\";\n}\n\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\n\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\n\n\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\n\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let location = useLocation();\n  let searchParams = React.useMemo(() => getSearchParamsForLocation(location.search, defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\n\nfunction useSubmit() {\n  return useSubmitImpl();\n}\n\nfunction useSubmitImpl(fetcherKey, routeId) {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\n  let defaultAction = useFormAction();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (typeof document === \"undefined\") {\n      throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n\n    let {\n      method,\n      encType,\n      formData,\n      url\n    } = getFormSubmissionInfo(target, defaultAction, options);\n    let href = url.pathname + url.search;\n    let opts = {\n      replace: options.replace,\n      formData,\n      formMethod: method,\n      formEncType: encType\n    };\n\n    if (fetcherKey) {\n      !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for useFetcher()\") : invariant(false) : void 0;\n      router.fetch(fetcherKey, routeId, href, opts);\n    } else {\n      router.navigate(href, opts);\n    }\n  }, [defaultAction, router, fetcherKey, routeId]);\n}\n\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFormAction must be used inside a RouteContext\") : invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  let resolvedAction = action != null ? action : \".\"; // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n\n  let path = _extends({}, useResolvedPath(resolvedAction, {\n    relative\n  })); // Previously we set the default action to \".\". The problem with this is that\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n  // URL. This is the intended behavior of when \".\" is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n\n\n  let location = useLocation();\n\n  if (action == null) {\n    // Safe to write to these directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    // or hash\n    path.search = location.search;\n    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  } // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n\n\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\nfunction createFetcherForm(fetcherKey, routeId) {\n  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n    return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n      ref: ref,\n      fetcherKey: fetcherKey,\n      routeId: routeId\n    }));\n  });\n\n  if (process.env.NODE_ENV !== \"production\") {\n    FetcherForm.displayName = \"fetcher.Form\";\n  }\n\n  return FetcherForm;\n}\n\nlet fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\n\nfunction useFetcher() {\n  var _route$matches;\n\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let route = React.useContext(UNSAFE_RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher must be used inside a RouteContext\") : invariant(false) : void 0;\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : invariant(false) : void 0;\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for fetcher.Form()\") : invariant(false) : void 0;\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => href => {\n    !router ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No router available for fetcher.load()\") : invariant(false) : void 0;\n    !routeId ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for fetcher.load()\") : invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitImpl(fetcherKey, routeId);\n  let fetcher = router.getFetcher(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form,\n    submit,\n    load\n  }, fetcher), [fetcher, Form, submit, load]);\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn(\"No fetcher available to clean up from useFetcher()\");\n        return;\n      }\n\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\n\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\n\nfunction useScrollRestoration(_temp3) {\n  let {\n    getKey,\n    storageKey\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation(); // Trigger manual scroll restoration while we're active\n\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []); // Save positions on unload\n\n  useBeforeUnload(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n\n    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations\n\n  React.useLayoutEffect(() => {\n    try {\n      let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n\n      if (sessionPositions) {\n        savedScrollPositions = JSON.parse(sessionPositions);\n      }\n    } catch (e) {// no-op, use default empty object\n    }\n  }, [storageKey]); // Enable scroll restoration in the router\n\n  React.useLayoutEffect(() => {\n    let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);\n    return () => disableScrollRestoration && disableScrollRestoration();\n  }, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes\n\n  React.useLayoutEffect(() => {\n    // Explicit false means don't do anything (used for submissions)\n    if (restoreScrollPosition === false) {\n      return;\n    } // been here before, scroll to it\n\n\n    if (typeof restoreScrollPosition === \"number\") {\n      window.scrollTo(0, restoreScrollPosition);\n      return;\n    } // try to scroll to the hash\n\n\n    if (location.hash) {\n      let el = document.getElementById(location.hash.slice(1));\n\n      if (el) {\n        el.scrollIntoView();\n        return;\n      }\n    } // Opt out of scroll reset if this link requested it\n\n\n    if (preventScrollReset === true) {\n      return;\n    } // otherwise go to the top on new locations\n\n\n    window.scrollTo(0, 0);\n  }, [location, restoreScrollPosition, preventScrollReset]);\n}\n\nfunction useBeforeUnload(callback) {\n  React.useEffect(() => {\n    window.addEventListener(\"beforeunload\", callback);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback);\n    };\n  }, [callback]);\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Utils\n////////////////////////////////////////////////////////////////////////////////\n\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n} //#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, ScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\n//# sourceMappingURL=index.js.map\n","/**\n * React Router v6.4.4\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { invariant, joinPaths, matchPath, UNSAFE_getPathContributingMatches, warning, resolveTo, parsePath, matchRoutes, Action, isRouteErrorResponse, createMemoryHistory, stripBasename, AbortedDeferredError, createRouter } from '@remix-run/router';\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, resolvePath } from '@remix-run/router';\nimport * as React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\n\nfunction isPolyfill(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nconst is = typeof Object.is === \"function\" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic\n// dispatch for CommonJS interop named imports.\n\nconst {\n  useState,\n  useEffect,\n  useLayoutEffect,\n  useDebugValue\n} = React;\nlet didWarnOld18Alpha = false;\nlet didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore$2(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!didWarnOld18Alpha) {\n      if (\"startTransition\" in React) {\n        didWarnOld18Alpha = true;\n        console.error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  const value = getSnapshot();\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!didWarnUncachedGetSnapshot) {\n      const cachedValue = getSnapshot();\n\n      if (!is(value, cachedValue)) {\n        console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  const [{\n    inst\n  }, forceUpdate] = useState({\n    inst: {\n      value,\n      getSnapshot\n    }\n  }); // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n  useLayoutEffect(() => {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst\n      });\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [subscribe, value, getSnapshot]);\n  useEffect(() => {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst\n      });\n    }\n\n    const handleStoreChange = () => {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n\n  try {\n    const nextValue = latestGetSnapshot();\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\n/**\n * Inlined into the react-router repo since use-sync-external-store does not\n * provide a UMD-compatible package, so we need this to be able to distribute\n * UMD react-router bundles\n */\nconst canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\nconst isServerEnvironment = !canUseDOM;\nconst shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;\nconst useSyncExternalStore = \"useSyncExternalStore\" in React ? (module => module.useSyncExternalStore)(React) : shim;\n\n// Contexts for data routers\nconst DataStaticRouterContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  DataStaticRouterContext.displayName = \"DataStaticRouterContext\";\n}\n\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\n\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\n\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\n\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\n\nconst LocationContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\n\nconst RouteContext = /*#__PURE__*/React.createContext({\n  outlet: null,\n  matches: []\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-href\n */\n\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context\n */\n\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-location\n */\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigation-type\n */\n\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-match\n */\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate\n */\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\") : void 0;\n    if (!activeRef.current) return;\n\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\"); // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history.  If this is a root navigation, then we\n    // navigate to the raw basename which allows the basename to have full\n    // control over the presence of a trailing slash on root links\n\n    if (basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/React.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet-context\n */\n\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet\n */\n\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n\n  if (outlet) {\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n\n  return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-params\n */\n\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-resolved-path\n */\n\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-routes\n */\n\nfunction useRoutes(routes, locationArg) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let dataRouterStateContext = React.useContext(DataRouterStateContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n\n  let locationFromContext = useLocation();\n  let location;\n\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" does not have an element. \" + \"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n\n\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n\n  return renderedMatches;\n}\n\nfunction DefaultErrorElement() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unhandled Thrown Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own\\xA0\", /*#__PURE__*/React.createElement(\"code\", {\n    style: codeStyles\n  }, \"errorElement\"), \" props on\\xA0\", /*#__PURE__*/React.createElement(\"code\", {\n    style: codeStyles\n  }, \"<Route>\")));\n}\n\nclass RenderErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      error: props.error\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location) {\n      return {\n        error: props.error,\n        location: props.location\n      };\n    } // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n\n\n    return {\n      error: props.error || state.error,\n      location: state.location\n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n\n  render() {\n    return this.state.error ? /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    }) : this.props.children;\n  }\n\n}\n\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataStaticRouterContext = React.useContext(DataStaticRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n\n  if (dataStaticRouterContext && match.route.errorElement) {\n    dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;\n  }\n\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\n\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n\n  if (matches == null) {\n    if (dataRouterState != null && dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n\n  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary\n\n  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;\n\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Could not find a matching route for the current errors: \" + errors) : invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors\n\n    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/React.createElement(DefaultErrorElement, null) : null;\n\n    let getChildren = () => /*#__PURE__*/React.createElement(RenderedRoute, {\n      match: match,\n      routeContext: {\n        outlet,\n        matches: parentMatches.concat(renderedMatches.slice(0, index + 1))\n      }\n    }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an\n    // errorElement on this route.  Otherwise let it bubble up to an ancestor\n    // errorElement\n\n\n    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      component: errorElement,\n      error: error,\n      children: getChildren()\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook;\n\n(function (DataRouterHook) {\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n})(DataRouterHook || (DataRouterHook = {}));\n\nvar DataRouterStateHook;\n\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.\";\n}\n\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return ctx;\n}\n\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\n  return state;\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\n\n\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\n\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return {\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  };\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\n\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(match => {\n    let {\n      pathname,\n      params\n    } = match; // Note: This structure matches that created by createUseMatchesMatch\n    // in the @remix-run/router , so if you change this please also change\n    // that :)  Eventually we'll DRY this up\n\n    return {\n      id: match.route.id,\n      pathname,\n      params,\n      data: loaderData[match.route.id],\n      handle: match.route.handle\n    };\n  }), [matches, loaderData]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\n\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useLoaderData must be used inside a RouteContext\") : invariant(false) : void 0;\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useLoaderData can only be used on routes that contain a unique \\\"id\\\"\") : invariant(false) : void 0;\n  return state.loaderData[thisRoute.route.id];\n}\n/**\n * Returns the loaderData for the given routeId\n */\n\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */\n\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useActionData must be used inside a RouteContext\") : invariant(false) : void 0;\n  return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * errorElement to display a proper error message.\n */\n\nfunction useRouteError() {\n  var _state$errors;\n\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let route = React.useContext(RouteContext);\n  let thisRoute = route.matches[route.matches.length - 1]; // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n\n  if (error) {\n    return error;\n  }\n\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useRouteError must be used inside a RouteContext\") : invariant(false) : void 0;\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useRouteError can only be used on routes that contain a unique \\\"id\\\"\") : invariant(false) : void 0; // Otherwise look for errors from our data router state\n\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];\n}\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\n\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\n\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nconst alreadyWarned = {};\n\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router\n  } = _ref;\n  // Sync router state to our component state to force re-renders\n  let state = useSyncExternalStore(router.subscribe, () => router.state, // We have to provide this so React@18 doesn't complain during hydration,\n  // but we pass our serialized hydration data into the router so state here\n  // is already synced with what the server saw\n  () => router.state);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  return /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\n    value: {\n      router,\n      navigator,\n      static: false,\n      // Do we need this?\n      basename\n    }\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: router.basename,\n    location: router.state.location,\n    navigationType: router.state.historyAction,\n    navigator: navigator\n  }, router.state.initialized ? /*#__PURE__*/React.createElement(Routes, null) : fallbackElement)));\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/memory-router\n */\nfunction MemoryRouter(_ref2) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex\n  } = _ref2;\n  let historyRef = React.useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/components/navigate\n */\nfunction Navigate(_ref3) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref3;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!React.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let dataRouterState = React.useContext(DataRouterStateContext);\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    // Avoid kicking off multiple navigations if we're in the middle of a\n    // data-router navigation, since components get re-rendered when we enter\n    // a submitting/loading state\n    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\n      return;\n    }\n\n    navigate(to, {\n      replace,\n      state,\n      relative\n    });\n  });\n  return null;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/components/route\n */\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false) ;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/router\n */\nfunction Router(_ref4) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref4;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : invariant(false) : void 0; // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key\n    };\n  }, [basename, pathname, search, hash, state, key]);\n  process.env.NODE_ENV !== \"production\" ? warning(location != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n\n  if (location == null) {\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      location,\n      navigationType\n    }\n  }));\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/components/routes\n */\nfunction Routes(_ref5) {\n  let {\n    children,\n    location\n  } = _ref5;\n  let dataRouterContext = React.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes\n  // directly.  If we have children, then we're in a descendant tree and we\n  // need to use child routes.\n\n  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);\n  return useRoutes(routes, location);\n}\n\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref6) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref6;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus;\n\n(function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n})(AwaitRenderStatus || (AwaitRenderStatus = {}));\n\nconst neverSettledPromise = new Promise(() => {});\n\nclass AwaitErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    } // Throw to the suspense boundary\n\n\n    throw promise;\n  }\n\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\n\n\nfunction ResolveAwait(_ref7) {\n  let {\n    children\n  } = _ref7;\n  let data = useAsyncValue();\n\n  if (typeof children === \"function\") {\n    return children(data);\n  }\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children\n */\n\n\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));\n      return;\n    }\n\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"An index route cannot have child routes.\") : invariant(false) : void 0;\n    let treePath = [...parentPath, index];\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      hasErrorBoundary: element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n\n    routes.push(route);\n  });\n  return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\n\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n/**\n * @private\n * Walk the route tree and add hasErrorBoundary if it's not provided, so that\n * users providing manual route arrays can just specify errorElement\n */\n\nfunction enhanceManualRouteObjects(routes) {\n  return routes.map(route => {\n    let routeClone = _extends({}, route);\n\n    if (routeClone.hasErrorBoundary == null) {\n      routeClone.hasErrorBoundary = routeClone.errorElement != null;\n    }\n\n    if (routeClone.children) {\n      routeClone.children = enhanceManualRouteObjects(routeClone.children);\n    }\n\n    return routeClone;\n  });\n}\n\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes: enhanceManualRouteObjects(routes)\n  }).initialize();\n} ///////////////////////////////////////////////////////////////////////////////\n\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, DataStaticRouterContext as UNSAFE_DataStaticRouterContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, enhanceManualRouteObjects as UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\n//# sourceMappingURL=index.js.map\n"],"names":["_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","defaultMethod","defaultEncType","isHtmlElement","object","tagName","getFormSubmissionInfo","defaultAction","options","method","action","encType","formData","toLowerCase","submissionTrigger","getAttribute","FormData","name","append","value","isButtonElement","isInputElement","type","form","Error","URLSearchParams","protocol","host","window","location","url","URL","_excluded","_excluded2","_excluded3","BrowserRouter","_ref","basename","children","historyRef","current","v5Compat","history","state","setState","listen","navigationType","navigator","Link","_ref4","ref","onClick","relative","reloadDocument","replace","to","preventScrollReset","rest","href","internalOnClick","_temp","replaceProp","navigate","path","event","button","metaKey","altKey","ctrlKey","shiftKey","isModifiedEvent","shouldProcessLinkClick","preventDefault","undefined","useLinkClickHandler","defaultPrevented","displayName","_ref5","ariaCurrentProp","caseSensitive","className","classNameProp","end","style","styleProp","routerState","toPathname","encodeLocation","pathname","locationPathname","nextLocationPathname","navigation","isActive","startsWith","charAt","isPending","ariaCurrent","filter","Boolean","join","props","FormImpl","_ref6","forwardedRef","onSubmit","fetcherKey","routeId","submit","useSubmitImpl","formMethod","formAction","useFormAction","submitter","nativeEvent","currentTarget","DataRouterHook","DataRouterStateHook","getDataRouterConsoleError","hookName","useDataRouterContext","ctx","router","UseSubmitImpl","document","search","opts","formEncType","fetch","_temp2","routeContext","match","matches","slice","resolvedAction","hash","route","index","params","delete","toString","is","x","y","useState","useEffect","useLayoutEffect","useDebugValue","didWarnOld18Alpha","didWarnUncachedGetSnapshot","checkIfSnapshotChanged","inst","latestGetSnapshot","getSnapshot","prevValue","nextValue","error","shim","createElement","subscribe","getServerSnapshot","console","cachedValue","forceUpdate","useSyncExternalStore","DataStaticRouterContext","DataRouterContext","DataRouterStateContext","AwaitContext","NavigationContext","LocationContext","RouteContext","outlet","RouteErrorContext","useHref","useInRouterContext","useResolvedPath","joinedPathname","createHref","useLocation","useNavigate","routePathnamesJson","JSON","stringify","map","pathnameBase","activeRef","go","parse","push","useParams","routeMatch","useRoutes","routes","locationArg","dataRouterStateContext","parentMatches","parentParams","parentPathname","parentPathnameBase","parentRoute","parentPath","cond","endsWith","message","alreadyWarned","locationFromContext","_parsedLocationArg$pa","parsedLocationArg","remainingPathname","element","renderedMatches","_renderMatches","Provider","Pop","DefaultErrorElement","_state$errors","useDataRouterState","UseRouteError","thisRoute","id","errors","useRouteError","status","statusText","stack","lightgrey","preStyles","padding","backgroundColor","codeStyles","fontStyle","RenderErrorBoundary","constructor","super","getDerivedStateFromError","getDerivedStateFromProps","componentDidCatch","errorInfo","render","component","RenderedRoute","dataStaticRouterContext","errorElement","_deepestRenderedBoundaryId","dataRouterState","errorIndex","findIndex","m","Math","min","reduceRight","getChildren","concat","useNavigation","UseNavigation","useMatches","loaderData","UseMatches","data","handle","Navigate","_ref3","static","Route","_props","Router","basenameProp","locationProp","staticProp","navigationContext","trailingPathname","Routes","dataRouterContext","createRoutesFromChildren","AwaitRenderStatus","Promise","forEach","treePath","loader","hasErrorBoundary","shouldRevalidate"],"sourceRoot":""}